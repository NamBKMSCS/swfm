SET statement_timeout = 0;

SET lock_timeout = 0;

SET idle_in_transaction_session_timeout = 0;

SET client_encoding = 'UTF8';

SET standard_conforming_strings = on;

SELECT pg_catalog.set_config ('search_path', '', false);

SET check_function_bodies = false;

SET xmloption = content;

SET client_min_messages = warning;

SET row_security = off;

COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";

CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"
WITH
    SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";

CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";

CREATE TYPE "public"."app_permission" AS ENUM (
    'users.manage',
    'data.manage',
    'models.tune',
    'data.download'
);

ALTER TYPE "public"."app_permission" OWNER TO "postgres";

CREATE TYPE "public"."app_role" AS ENUM (
    'admin',
    'data_scientist'
);

ALTER TYPE "public"."app_role" OWNER TO "postgres";

CREATE TYPE "public"."user_status" AS ENUM (
    'pending',
    'active',
    'rejected'
);

ALTER TYPE "public"."user_status" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."authorize"("requested_permission" "public"."app_permission", "user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$$;

ALTER FUNCTION "public"."authorize"("requested_permission" "public"."app_permission", "user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  declare
    user_count int;
    requested_role public.app_role;
  begin
    -- Count existing users to determine if this is the first user
    select count(*) from public.users into user_count;

    -- Insert into public.users
    insert into public.users (id, email, full_name, status)
    values (
      new.id, 
      new.email, 
      new.raw_user_meta_data->>'full_name',
      case 
        when user_count = 0 then 'active'::public.user_status
        else 'pending'::public.user_status
      end
    );

    -- Determine role
    if user_count = 0 then
      -- First user is always admin
      insert into public.user_roles (user_id, role) values (new.id, 'admin');
    else
      -- Subsequent users get role from metadata (default to data_scientist if missing)
      -- We trust the metadata here because the status is pending anyway
      requested_role := coalesce(
        (new.raw_user_meta_data->>'role')::public.app_role, 
        'data_scientist'::public.app_role
      );
      
      -- Prevent non-first users from becoming admins via metadata hacking (optional but good practice)
      -- If they request admin, we can either allow it (pending approval) or force data_scientist.
      -- The requirement says "The sign up should only create a pending account where admin need to approve".
      -- It implies they CAN request admin. So we allow it.
      insert into public.user_roles (user_id, role) values (new.id, requested_role);
    end if;

    return new;
  end;
$$;

ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."forecasts" (
    "id" bigint NOT NULL,
    "station_id" bigint NOT NULL,
    "forecast_date" timestamp with time zone NOT NULL,
    "target_date" timestamp with time zone NOT NULL,
    "water_level" numeric
);

ALTER TABLE "public"."forecasts" OWNER TO "postgres";

ALTER TABLE "public"."forecasts"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."forecasts_id_seq" START
    WITH
        1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."measurements" (
    "id" bigint NOT NULL,
    "station_id" bigint NOT NULL,
    "measured_at" timestamp with time zone NOT NULL,
    "water_level" numeric,
    "flow_rate" numeric,
    "rainfall" numeric,
    "created_at" timestamp with time zone DEFAULT "timezone" ('utc'::"text", "now" ()) NOT NULL,
    "rainfall_1h" numeric,
    "rainfall_6h" numeric,
    "rainfall_12h" numeric,
    "rainfall_24h" numeric,
    "rainfall_7to7" numeric,
    "fetched_at" timestamp with time zone,
    "source" "text" DEFAULT 'automated'::"text",
    "status" "text" DEFAULT 'verified'::"text",
    "unit" "text" DEFAULT 'meters'::"text",
    CONSTRAINT "measurements_source_check" CHECK (
        (
            "source" = ANY (
                ARRAY[
                    'manual'::"text",
                    'automated'::"text"
                ]
            )
        )
    ),
    CONSTRAINT "measurements_status_check" CHECK (
        (
            "status" = ANY (
                ARRAY[
                    'verified'::"text",
                    'pending'::"text",
                    'rejected'::"text"
                ]
            )
        )
    )
);

ALTER TABLE "public"."measurements" OWNER TO "postgres";

ALTER TABLE "public"."measurements"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."measurements_id_seq" START
    WITH
        1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."role_permissions" (
    "id" bigint NOT NULL,
    "role" "public"."app_role" NOT NULL,
    "permission" "public"."app_permission" NOT NULL
);

ALTER TABLE "public"."role_permissions" OWNER TO "postgres";

ALTER TABLE "public"."role_permissions"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."role_permissions_id_seq" START
    WITH
        1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."stations" (
    "id" bigint NOT NULL,
    "station_code" "text" NOT NULL,
    "name" "text" NOT NULL,
    "latitude" double precision NOT NULL,
    "longitude" double precision NOT NULL,
    "region" "text",
    "created_at" timestamp with time zone DEFAULT "timezone" ('utc'::"text", "now" ()) NOT NULL,
    "country" "text",
    "river" "text",
    "alarm_level" numeric,
    "flood_level" numeric,
    "is_deleted" boolean DEFAULT false
);

ALTER TABLE "public"."stations" OWNER TO "postgres";

COMMENT ON TABLE "public"."stations" IS 'Geographic locations of water monitoring stations.';

ALTER TABLE "public"."stations"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."stations_id_seq" START
    WITH
        1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."user_roles" (
    "id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "public"."app_role" NOT NULL
);

ALTER TABLE "public"."user_roles" OWNER TO "postgres";

ALTER TABLE "public"."user_roles"
ALTER COLUMN "id"
ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_roles_id_seq" START
    WITH
        1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" NOT NULL,
    "email" "text",
    "full_name" "text",
    "created_at" timestamp with time zone DEFAULT "timezone" ('utc'::"text", "now" ()) NOT NULL,
    "status" "public"."user_status" DEFAULT 'pending'::"public"."user_status" NOT NULL
);

ALTER TABLE "public"."users" OWNER TO "postgres";

COMMENT ON TABLE "public"."users" IS 'Profile data for SWFM users.';

COMMENT ON COLUMN "public"."users"."id" IS 'References the internal Supabase Auth user.';

ALTER TABLE ONLY "public"."forecasts"
ADD CONSTRAINT "forecasts_station_id_target_date_forecast_date_key" UNIQUE (
    "station_id",
    "target_date",
    "forecast_date"
);

ALTER TABLE ONLY "public"."forecasts"
ADD CONSTRAINT "forecasts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."measurements"
ADD CONSTRAINT "measurements_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."measurements"
ADD CONSTRAINT "measurements_station_id_measured_at_key" UNIQUE ("station_id", "measured_at");

ALTER TABLE ONLY "public"."role_permissions"
ADD CONSTRAINT "role_permissions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."role_permissions"
ADD CONSTRAINT "role_permissions_role_permission_key" UNIQUE ("role", "permission");

ALTER TABLE ONLY "public"."stations"
ADD CONSTRAINT "stations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."stations"
ADD CONSTRAINT "stations_station_code_key" UNIQUE ("station_code");

ALTER TABLE ONLY "public"."user_roles"
ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_roles"
ADD CONSTRAINT "user_roles_user_id_role_key" UNIQUE ("user_id", "role");

ALTER TABLE ONLY "public"."users"
ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");

CREATE INDEX "idx_measurements_station" ON "public"."measurements" USING "btree" ("station_id");

CREATE INDEX "idx_measurements_time" ON "public"."measurements" USING "btree" ("measured_at");

ALTER TABLE ONLY "public"."forecasts"
ADD CONSTRAINT "forecasts_station_id_fkey" FOREIGN KEY ("station_id") REFERENCES "public"."stations" ("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."measurements"
ADD CONSTRAINT "measurements_station_id_fkey" FOREIGN KEY ("station_id") REFERENCES "public"."stations" ("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_roles"
ADD CONSTRAINT "user_roles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users" ("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."users"
ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users" ("id") ON DELETE CASCADE;

CREATE POLICY "Allow admin delete access" ON "public"."users" FOR DELETE USING (
    "public"."authorize" (
        'users.manage'::"public"."app_permission",
        "auth"."uid" ()
    )
);

CREATE POLICY "Allow admin full access" ON "public"."stations" USING (
    "public"."authorize" (
        'data.manage'::"public"."app_permission",
        "auth"."uid" ()
    )
);

CREATE POLICY "Allow admin insert/update/delete" ON "public"."measurements" USING (
    "public"."authorize" (
        'data.manage'::"public"."app_permission",
        "auth"."uid" ()
    )
);

CREATE POLICY "Allow experts/admins to insert forecasts" ON "public"."forecasts" FOR INSERT
WITH
    CHECK (
        (
            "public"."authorize" (
                'models.tune'::"public"."app_permission",
                "auth"."uid" ()
            )
            OR "public"."authorize" (
                'data.manage'::"public"."app_permission",
                "auth"."uid" ()
            )
        )
    );

CREATE POLICY "Allow individual read access" ON "public"."user_roles" FOR
SELECT USING (
        (
            (
                SELECT "auth"."uid" () AS "uid"
            ) = "user_id"
        )
    );

CREATE POLICY "Allow individual update access" ON "public"."users"
FOR UPDATE
    USING (
        (
            (
                SELECT "auth"."uid" () AS "uid"
            ) = "id"
        )
    );

CREATE POLICY "Allow logged-in read access" ON "public"."users" FOR
SELECT USING (
        (
            "auth"."role" () = 'authenticated'::"text"
        )
    );

CREATE POLICY "Allow public read access" ON "public"."forecasts" FOR
SELECT USING (true);

CREATE POLICY "Allow public read access" ON "public"."measurements" FOR
SELECT USING (true);

CREATE POLICY "Allow public read access" ON "public"."stations" FOR
SELECT USING (true);

ALTER TABLE "public"."forecasts" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."measurements" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."role_permissions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."stations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;

ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."authorize"("requested_permission" "public"."app_permission", "user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."authorize" (
    "requested_permission" "public"."app_permission",
    "user_id" "uuid"
) TO "authenticated";

GRANT ALL ON FUNCTION "public"."authorize" (
    "requested_permission" "public"."app_permission",
    "user_id" "uuid"
) TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_user" () TO "service_role";

GRANT ALL ON TABLE "public"."forecasts" TO "anon";

GRANT ALL ON TABLE "public"."forecasts" TO "authenticated";

GRANT ALL ON TABLE "public"."forecasts" TO "service_role";

GRANT ALL ON SEQUENCE "public"."forecasts_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."forecasts_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."forecasts_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."measurements" TO "anon";

GRANT ALL ON TABLE "public"."measurements" TO "authenticated";

GRANT ALL ON TABLE "public"."measurements" TO "service_role";

GRANT ALL ON SEQUENCE "public"."measurements_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."measurements_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."measurements_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."role_permissions" TO "anon";

GRANT ALL ON TABLE "public"."role_permissions" TO "authenticated";

GRANT ALL ON TABLE "public"."role_permissions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."role_permissions_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."role_permissions_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."role_permissions_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."stations" TO "anon";

GRANT ALL ON TABLE "public"."stations" TO "authenticated";

GRANT ALL ON TABLE "public"."stations" TO "service_role";

GRANT ALL ON SEQUENCE "public"."stations_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."stations_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."stations_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."user_roles" TO "anon";

GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";

GRANT ALL ON TABLE "public"."user_roles" TO "service_role";

GRANT ALL ON SEQUENCE "public"."user_roles_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."user_roles_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."user_roles_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."users" TO "anon";

GRANT ALL ON TABLE "public"."users" TO "authenticated";

GRANT ALL ON TABLE "public"."users" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public"
GRANT ALL ON TABLES TO "service_role";

drop extension if exists "pg_net";

drop policy "Allow experts/admins to insert forecasts" on "public"."forecasts";

drop policy "Allow admin insert/update/delete" on "public"."measurements";

drop policy "Allow admin full access" on "public"."stations";

drop policy "Allow admin delete access" on "public"."users";

alter table "public"."forecasts"
drop constraint "forecasts_station_id_fkey";

alter table "public"."measurements"
drop constraint "measurements_station_id_fkey";

alter table "public"."user_roles"
drop constraint "user_roles_user_id_fkey";

drop function if exists "public"."authorize" (
    requested_permission app_permission,
    user_id uuid
);

alter table "public"."role_permissions"
alter column "permission"
set data type public.app_permission using "permission"::text::public.app_permission;

alter table "public"."role_permissions"
alter column "role"
set data type public.app_role using "role"::text::public.app_role;

alter table "public"."user_roles"
alter column "role"
set data type public.app_role using "role"::text::public.app_role;

alter table "public"."users"
alter column "status"
set default 'pending'::public.user_status;

alter table "public"."users"
alter column "status"
set data type public.user_status using "status"::text::public.user_status;

alter table "public"."forecasts"
add constraint "forecasts_station_id_fkey" FOREIGN KEY (station_id) REFERENCES public.stations (id) ON DELETE CASCADE not valid;

alter table "public"."forecasts" validate constraint "forecasts_station_id_fkey";

alter table "public"."measurements"
add constraint "measurements_station_id_fkey" FOREIGN KEY (station_id) REFERENCES public.stations (id) ON DELETE CASCADE not valid;

alter table "public"."measurements" validate constraint "measurements_station_id_fkey";

alter table "public"."user_roles"
add constraint "user_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.users (id) ON DELETE CASCADE not valid;

alter table "public"."user_roles" validate constraint "user_roles_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.authorize(requested_permission public.app_permission, user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
  declare
    bind_permissions int;
  begin
    select
      count(*)
    from public.role_permissions
    inner join public.user_roles on role_permissions.role = user_roles.role
    where
      role_permissions.permission = authorize.requested_permission and
      user_roles.user_id = authorize.user_id
    into bind_permissions;

    return bind_permissions > 0;
  end;
$function$
;

create policy "Allow experts/admins to insert forecasts" on "public"."forecasts" as permissive for insert to public
with
    check (
        (
            public.authorize (
                'models.tune'::public.app_permission,
                auth.uid ()
            )
            OR public.authorize (
                'data.manage'::public.app_permission,
                auth.uid ()
            )
        )
    );

create policy "Allow admin select" on "public"."measurements" as permissive for
select to public using (
        public.authorize (
            'data.manage'::public.app_permission, auth.uid ()
        )
    );

create policy "Allow admin insert" on "public"."measurements" as permissive for insert to public
with
    check (
        public.authorize (
            'data.manage'::public.app_permission,
            auth.uid ()
        )
    );

create policy "Allow admin update" on "public"."measurements" as permissive
for update
    to public using (
        public.authorize (
            'data.manage'::public.app_permission,
            auth.uid ()
        )
    )
with
    check (
        public.authorize (
            'data.manage'::public.app_permission,
            auth.uid ()
        )
    );

create policy "Allow admin delete" on "public"."measurements" as permissive for delete to public using (
    public.authorize (
        'data.manage'::public.app_permission,
        auth.uid ()
    )
);

create policy "Allow admin full access" on "public"."stations" as permissive for all to public using (
    public.authorize (
        'data.manage'::public.app_permission,
        auth.uid ()
    )
);

create policy "Allow admin delete access" on "public"."users" as permissive for delete to public using (
    public.authorize (
        'users.manage'::public.app_permission,
        auth.uid ()
    )
);

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();